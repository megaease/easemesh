/*
 * Copyright (c) 2017, MegaEase
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"fmt"
	"go/ast"

	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
)

type (
	meshClientVisitor struct {
		err          error
		getterID     string
		interfaceID  string
		resourceName string
		builder      interfaceMethodBuilder
	}

	converter struct {
		err      error
		funcType *ast.FuncType
		funcName string
	}
)

var _ interfaceVisitor = &meshClientVisitor{}

func (m *meshClientVisitor) visitorBegin(buf *jen.File) error {
	buf.PackageComment("Code generated by github.com/megaease/easemeshctl/cmd/generator, DO NOT EDIT.")
	return nil
}
func (m *meshClientVisitor) visitorResourceGetterConcreatStruct(name string, buf *jen.File) error {
	fmt.Printf("resourcegetter visitor\n")
	buf.Type().Id(name).Struct(jen.Id("client").Qual("", "*meshClient"))
	m.getterID = name
	return nil
}
func (m *meshClientVisitor) visitorInterfaceConcreatStruct(name string, buf *jen.File) error {
	fmt.Printf("interface visitor\n")
	buf.Type().Id(name).Struct(jen.Id("client").Qual("", "*meshClient"))
	m.interfaceID = name
	return nil
}
func (m *meshClientVisitor) visitorResourceGetterMethod(name string, method *ast.Field, buf *jen.File) error {

	var arguments, results []jen.Code
	err := covertFuncType(method).extractArguments(&arguments).extractResults(&results).error()
	if err != nil {
		return errors.Wrapf(err, "extract arguments and result from method error")
	}

	fmt.Printf("param is %+v, results %+v\n", arguments, results)
	buf.Func().Params(
		jen.Id(string(m.getterID[0])).Op("*").Id(m.getterID),
	).Id(name).Params(arguments...).Params(results...).BlockFunc(func(grp *jen.Group) {
		grp.Return(jen.Op("&").Id(m.interfaceID).Values(jen.Dict{
			jen.Id("client"): jen.Id("c").Dot("client"),
		}))
	})
	return nil
}
func (m *meshClientVisitor) visitorIntrefaceMethod(verb Verb, method *ast.Field, buf *jen.File) error {

	var err error
	switch verb {
	case Get:
		err = m.builder.buildGetMethod(m.resourceName, m.interfaceID, method, buf)
	case Patch:
		err = m.builder.buildPatchMethod(m.resourceName, m.interfaceID, method, buf)
	case Delete:
		err = m.builder.buildDeleteMethod(m.resourceName, m.interfaceID, method, buf)
	case List:
		err = m.builder.buildListMethod(m.resourceName, m.interfaceID, method, buf)
	case Create:
		err = m.builder.buildCreateMethod(m.resourceName, m.interfaceID, method, buf)
	}
	if err != nil {
		return errors.Wrapf(err, "build %s interface method error", verb)
	}
	return nil
}
func (m *meshClientVisitor) visitorEnd(buf *jen.File) error {
	return nil
}
func (m *meshClientVisitor) onError(e error) { m.err = e }

func funcIdens(fields []*ast.Field, withID bool) (codes []jen.Code) {
	for i, r := range fields {
		var statement *jen.Statement
		if len(r.Names) != 0 {
			statement = jen.Id(r.Names[0].Name)
		} else if withID {
			statement = jen.Id(fmt.Sprintf("args_%d", i))
		}
		switch r.Type.(type) {
		case *ast.Ident:
			iden := r.Type.(*ast.Ident)
			if statement == nil {
				statement = jen.Id(iden.Name)
			} else {
				statement.Id(iden.Name)

			}
		case *ast.SelectorExpr:
			selectExpr := r.Type.(*ast.SelectorExpr)
			x := selectExpr.X.(*ast.Ident)
			statement.Qual(x.Name, selectExpr.Sel.Name)
		}
		codes = append(codes, statement)
	}
	return
}

func covertFuncType(method *ast.Field) *converter {
	var err error
	funcType, ok := method.Type.(*ast.FuncType)
	if !ok {
		err = errors.Errorf("method should contain a functype")
		return &converter{}
	}

	if len(method.Names) == 0 {
		err = errors.Errorf("func name is reqired")
	}

	return &converter{funcType: funcType, err: err, funcName: method.Names[0].Name}
}

func (c *converter) extractArguments(codes *[]jen.Code) *converter {
	if c.err == nil {
		*codes = append(*codes, funcIdens(c.funcType.Params.List, true)...)
	}
	return c
}

func (c *converter) extractResults(codes *[]jen.Code) *converter {
	if c.err == nil {
		*codes = append(*codes, funcIdens(c.funcType.Results.List, false)...)
	}
	return c
}
func (c *converter) extractFuncName(name *string) *converter {
	if c.err == nil {
		*name = c.funcName
	}
	return c
}

func (c *converter) error() error { return c.err }
